public class Main {
    /**
     * Helper method to print the elements of an array in a specific format.
     *
     * @param arr The input array.
     */
    public static void printArrayHelper (int[] arr) {
        printArrayHelper(arr, 0, "(");
    }

    /**
     * Recursive helper method to print the elements of an array in a specific format.
     *
     * @param arr The input array.
     * @param i   The current index in the array.
     * @param s   The string to be printed.
     */
    private static void printArrayHelper (int[] arr, int i, String s) {
        if (i > arr.length - 1)
            return;
        if (i == arr.length - 1)
            System.out.println(s + arr[i] + ")");

        s += arr[i] + ", ";
        printArrayHelper(arr, i + 1, s);
    }

    /**
     * Checks if there exists a subset of elements in the array that adds up to a given target sum.
     * The subset must include at most three contiguous elements.
     *
     * @param a   The input array.
     * @param num The target sum.
     * @return True if such a subset exists, false otherwise.
     */
    public static boolean isSum (int[] a, int num) {
        if (num == 0)
            return true;
        return isSum(a, num, 0, 0, 0, false);
    }

    /**
     * Recursive helper method to check if there exists a subset of elements in the array that adds up to a given target sum.
     *
     * @param a            The input array.
     * @param num          The target sum.
     * @param i            The current index in the array.
     * @param sumToSub     The current sum of elements to subtract.
     * @param indicator    An indicator for contiguous elements.
     * @param usedPrevious Flag indicating whether the previous element was used.
     * @return True if such a subset exists, false otherwise.
     */
    private static boolean isSum (int[] a, int num, int i, int sumToSub, int indicator, boolean usedPrevious) {
        if (num - sumToSub == 0)
            return true;
        if (i >= a.length) // passed the end of the array
            return false;

        if (indicator >= 3) {  // Checks if the three indexes are contiguous
            return false;
        }

        boolean included = false;
        if (usedPrevious && i > 0 && a[i] == a[i - 1]) {
            included = isSum(a, num, i + 1, sumToSub + a[i], indicator + 1, true);
        } else {
            included = isSum(a, num, i + 1, sumToSub + a[i], 1, true);
        }

        boolean excluded = isSum(a, num, i + 1, sumToSub, 0, false);

        return included || excluded;
    }

    /**
     * Calculates the minimum cost of reaching the end by traversing either of the two roads.
     * The cost is the sum of the values at each position.
     *
     * @param road1 The first road represented as an array of integers.
     * @param road2 The second road represented as an array of integers.
     * @return The minimum cost to reach the end.
     */
    public static int shortestRoad (int[] road1, int[] road2) {
        if (road1.length == 1)
            return Math.min(road1[0], road2[0]);

        int r1SumLeft = 0, r2SumLeft = 0, r1SumRight = 0, r2SumRight = 0;
        int minR1Sum = 0, minR2Sum = 0;

        for (int i = 0; i <= road1.length - 1; i++) {
            r1SumLeft += road1[i];
            r2SumLeft += road2[i];
        }
        for (int j = road1.length - 1; j >= 0; j--) {
            r1SumRight += road1[j];
            r2SumRight += road2[j];
            if (r1SumLeft - r1SumRight + r2SumRight < r1SumLeft) {
                minR1Sum = r1SumLeft + r1SumRight - r2SumRight;
            }
            if (r2SumLeft + r1SumRight - r2SumRight < r2SumLeft) {
                minR2Sum = r2SumLeft + r1SumRight - r2SumRight;
            }
        }
        return Math.min(minR1Sum, minR2Sum);
    }

    /**
     * Finds the length of the longest palindrome subsequence in an array.
     *
     * @param arr The input array.
     * @return The length of the longest palindrome subsequence.
     */
    public static int longestPalindrome (int[] arr) {
        if (arr.length <= 1)
            return 1;
        return longestPalindrome(arr, 0, arr.length - 1);
    }

    /**
     * Recursive helper method to find the length of the longest palindrome subsequence in an array.
     *
     * @param arr The input array.
     * @param i   The start index.
     * @param j   The end index.
     * @return The length of the longest palindrome subsequence.
     */
    private static int longestPalindrome (int[] arr, int i, int j) {
        if (i < 0 || i > arr.length - 1 || j < 0 || j > arr.length - 1)
            return 0;

        if (isPalindrom(arr, i, j)) {
            return j - i + 1;
        }
        return Math.max(longestPalindrome(arr, i + 1, j - 1),
                Math.max(longestPalindrome(arr, i + 1, j), longestPalindrome(arr, i, j - 1)));
    }

    /**
     * Helper method to check if the subarray from index i to j is a palindrome.
     *
     * @param arr The input array.
     * @param i   The start index.
     * @param j   The end index.
     * @return True if the subarray is a palindrome, false otherwise.
     */
    private static boolean isPalindrom (int[] arr, int i, int j) {
        int length = Math.abs(i - j);

        if (length <= 1 && arr[i] == arr[j])
            return true;
        return arr[i] == arr[j] && isPalindrom(arr, i + 1, j - 1);
    }

    /**
     * Finds a missing value in an arithmetic series represented by an array.
     *
     * @param arr The input array.
     * @return The missing value in the series.
     */
    public static int missingValue (int[] arr) {
        if (arr.length <= 1)
            return 0;

        // find d
        int d;
        int d1 = arr[1] - arr[0];
        int d2 = arr[arr.length - 1] - arr[arr.length - 2];
        d = Math.min(d1, d2);

        //find the missing value
        int left = 0, right = arr.length - 1, middle = arr.length / 2, S1;

        while (left <= right) {

            middle = (left + right) / 2;
            S1 = sumSeries(arr, left, right);

            if (arr[middle] - arr[middle - 1] != d)
                return arr[middle - 1] + d;

            if (S1 == ((((arr[left] + arr[right]) * (right)) / 2))) {
                right = middle - 1;
            } else {
                left = middle + 1;
            }
        }
        return arr[middle - 1] + d;
    }

    /**
     * Helper method to calculate the sum of the series in a given range.
     *
     * @param arr   The input array.
     * @param left  The left boundary.
     * @param right The right boundary.
     * @return The sum of the series in the given range.
     */
    public static int sumSeries (int[] arr, int left, int right) {
        int S1 = 0;
        for (int i = left; i <= right; i++) {
            S1 += arr[i];
        }
        return S1;
    }

    /**
     * Calculates the number of sorted sequences of length 'n' with elements not exceeding 'max'.
     *
     * @param n   The length of the sequences.
     * @param max The maximum value for elements in the sequences.
     * @return The number of sorted sequences.
     */
    public static int howManySorted (int n, int max) {
        if (n < 1)
            return 0;
        return howManySorted(n, max, 1);
    }

    /**
     * Recursive helper method to calculate the number of sorted sequences of length 'n' with elements not exceeding 'max'.
     *
     * @param n   The length of the sequences.
     * @param max The maximum value for elements in the sequences.
     * @param j   The current index.
     * @return The number of sorted sequences.
     */
    private static int howManySorted (int n, int max, int j) {
        if (n == 0)
            return 1;

        if (j > max)
            return 0;

        return howManySorted(n, max, j + 1) + howManySorted(n - 1, max, j);
    }

    /**
     * Checks if there exists a subsequence in an array that sums up to a given target number.
     *
     * @param a   The input array.
     * @param num The target sum.
     * @return True if such a subsequence exists, false otherwise.
     */
    public static boolean what (int[] a, int num) {
        int right = a.length - 1, left = 0, res = function(a, left, right);

        while (left <= right) {

            if (res == num)
                return true;

            if (res < num) {
                if (right - 1 == 0)
                    break;
                right--;
                res -= a[left];
            } else if (res > num) {
                left++;
                res -= a[left];
            }
        }
        return false;
    }

    /**
     * Helper method to calculate the sum of elements in a given range.
     *
     * @param a    The input array.
     * @param low  The lower bound of the range.
     * @param high The upper bound of the range.
     * @return The sum of elements in the range.
     */
    private static int function (int[] a, int low, int high) {
        int res = 0;
        for (int i = low; i <= high; i++)
            res += a[i];
        return res;
    }

    /**
     * Counts the number of rectangular regions in a boolean matrix where all elements are 'true'.
     *
     * @param mat The boolean matrix.
     * @return The number of true rectangular regions.
     */
    public static int cntTrueReg (boolean[][] mat) {
        if (mat.length == 0)
            return 0;
        if (mat.length == 1) {
            if (mat[0][0]) {
                return 1;
            } else {
                return 0;
            }
        }
        return cntTrueReg(mat, 0, 0);
    }

    /**
     * Recursive helper method to count the number of true rectangular regions in a boolean matrix.
     *
     * @param mat The boolean matrix.
     * @param i   The current row index.
     * @param j   The current column index.
     * @return The number of true rectangular regions.
     */
    public static int cntTrueReg (boolean[][] mat, int i, int j) {

        int counter = 0;
        if (i > mat.length - 1 || j > mat[0].length - 1)
            return 0;

        if (i == mat.length - 1 && j == mat.length - 1) {
            if (mat[i][j]) {
                return 1;
            }
            return 0;
        }

        // reach the end of row
        if (j == mat.length - 1) {
            if (!mat[i + 1][j] && mat[i][j]) {
                return 1 + cntTrueReg(mat, i + 1, 0);
            }
            return cntTrueReg(mat, i + 1, 0);
        }

        // reach the end of col
        if (i == mat.length - 1) {
            if (!mat[i][j + 1] && mat[i][j]) {
                return 1 + cntTrueReg(mat, i, j + 1);
            }
            return cntTrueReg(mat, i, j + 1);
        }

        // in the middle of the mat
        if (i < mat.length - 1 && j < mat.length - 1) {
            if (!mat[i][j + 1] && !mat[i + 1][j] && !mat[i + 1][j + 1]) {
                if (mat[i][j]) {
                    return 1 + cntTrueReg(mat, i, j + 1);
                }
            }
            return cntTrueReg(mat, i, j + 1);
        }
        return cntTrueReg(mat, i + 1, j) + cntTrueReg(mat, i, j + 1);
    }

    /**
     * Computes the minimum number of edits required to transform str1 into str2.
     *
     * @param str1 The first input string.
     * @param str2 The second input string.
     * @return The minimum number of edits needed.
     */
    public static int edit (String str1, String str2) {
        return edit(str1, str2, 0, 0, "");
    }

    /**
     * Recursive helper method for the edit operation.
     *
     * @param str1 The first input string.
     * @param str2 The second input string.
     * @param i    Current index in str1.
     * @param j    Current index in str2.
     * @param s    Current substring being formed.
     * @return The minimum number of edits needed.
     */
    private static int edit (String str1, String str2, int i, int j, String s) {
        // Base cases
        if (str2.equals(s) && i < str1.length() - 1)
            return 1 + edit(str1, str2, i + 1, j, s);
        if (str2.equals(s) && i >= str1.length() - 1)
            return 0;
        if (i >= str1.length() && j < str2.length() - 1)
            return 1 + edit(str1, str2, i, j + 1, s + str1.charAt(j));
        if (j >= str2.length() && i < str1.length())
            return 1 + edit(str1, str2, i + 1, j, s + str1.charAt(j));

        // Recursive cases
        if (str1.charAt(i) == str2.charAt(j))
            return edit(str1, str2, i + 1, j + 1, s + str2.charAt(j));
        if (str1.charAt(i) != str2.charAt(j) && str1.charAt(i + 1) != str2.charAt(j))
            return 1 + edit(str1, str2, i, j + 1, s + str2.charAt(j));
        else
            return 1 + edit(str1, str2, i + 1, j, s);
    }

    /**
     * Counts the number of triplets in the given array whose sum is equal to the given num.
     *
     * @param arr The input array of integers.
     * @param num The target sum.
     * @return The count of triplets.
     */
    public static int countTriplets (int[] arr, int num) {

        if (arr.length < 3)
            return 0;

        int n = arr.length, count = 0;
        int target, middle = 0;

        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {

                int left = j + 1, right = n - 1;
                target = num - arr[i] - arr[j];

                while (left <= right) {

                    middle = (right + left) / 2;

                    if (target - arr[middle] <= 0) {
                        right = middle - 1;
                    } else {
                        count += (middle - left + 1);
                        left = middle + 1;
                    }
                }
            }
        }
        return count;
    }

    /**
     * Checks if the given array 'a' matches the specified pattern.
     *
     * @param a       The input array of integers.
     * @param pattern The pattern array.
     * @return True if the array matches the pattern, false otherwise.
     */
    public static boolean match (int[] a, int[] pattern) {
        if (a.length < 1)
            return false;
        if (pattern.length < 1)
            return true;

        return match(a, pattern, 0, 0);
    }

    public static boolean match (int[] a, int[] pattern, int i, int j) {

        // passed the a array boundary
        if (i > a.length - 1)
            return false;
        // passed the pattern array boundary
        if (j == pattern.length)
            return false;

        boolean current = (a[i] / 10 == 1 && pattern[j] <= 1) || (a[i] / 10 >= 1 && a[i] / 10 < 10 && pattern[j] == 2);

        // reach the last index in pattern
        if (j == pattern.length - 1) {
            return current;
        }

        if (current && match(a, pattern, i + 1, j + 1))
            return true;
        // the pattern doesn't exist for j+1 and i+1 therefore need to start over with j=0
        return match(a, pattern, i + 1, 0);

    }

    /**
     * Sorts the array 'arr' in a special cross-sort pattern.
     *
     * @param arr The input array of integers.
     */
    public static void crossSort (int[] arr) {
        int[] temp = new int[arr.length];
        int i = 0;
        int j;
        if (arr.length % 2 == 0)
            j = arr.length - 1;
        else
            j = arr.length - 2;
        for (int k = 0; k < temp.length; k++) {
            if (i < arr.length && j > -1) {
                if (arr[i] <= arr[j]) {
                    temp[k] = arr[i];
                    i += 2;
                } else {
                    temp[k] = arr[j];
                    j -= 2;
                }
            } else if (i >= arr.length) {
                temp[k] = arr[j];
                j -= 2;
            } else {
                temp[k] = arr[i];
                i += 2;
            }
        }
        for (int ind = 0; ind < temp.length; ind++) {
            arr[ind] = temp[ind];
        }
    }

    /**
     * Searches for the index of the specified element 'x' in the cross-sorted array 'arr'.
     *
     * @param arr The input cross-sorted array of integers.
     * @param x   The element to search for.
     * @return The index of the element 'x' in the array, or -1 if not found.
     */
    public static int crossSearch (int[] arr, int x) {

        boolean lengthIsOdd = arr.length % 2 == 0;

        int leftEven = 0, rightEven = arr.length - 1;
        int leftOdd = 1, rightOdd = arr.length - 2, midOdd = 0, midEven = 0;

        if (lengthIsOdd) {
            rightOdd = arr.length - 1;
            rightEven = arr.length - 2;
        }
        boolean pastEven = true, pastOdd = true;

        while (pastEven || pastOdd) {

            if (leftEven > rightEven)
                pastEven = false;
            if (leftOdd > rightOdd)
                pastOdd = false;

            midEven = ((rightEven + leftEven) / 2);
            if (midEven % 2 == 1)
                midEven--;
            midOdd = ((rightOdd + leftOdd) / 2);
            if (midOdd % 2 == 0)
                midOdd++;

            //x has been found
            if (arr[midEven] == x)
                return midEven;
            if (arr[midOdd] == x)
                return midOdd;

            if (x < arr[midEven]) {
                rightEven = midEven - 2;
            } else {
                leftEven = midEven + 2;
            }

            if (x < arr[midOdd]) {
                leftOdd = midOdd + 2;
            } else {
                rightOdd = midOdd - 2;
            }
        }
        return -1;
    }


    /**
     * Prints all possible paths through a 2D matrix 'm' from the top-left to the bottom-right.
     *
     * @param m The input 2D matrix.
     */
    public static void printPathWeights (int[][] m) {
        if (m.length < 1 || m[0].length < 1)
            return;
        printPathWeights(m, 0, 0, 0);
    }

    /**
     * Prints all possible paths through a 2D matrix 'm' from the top-left to the bottom-right.
     *
     * @param m The input 2D matrix.
     */
    public static void printPathWeights (int[][] m, int i, int j, int sum) {

        // index i out of boundary
        if (i < 0 || i > m.length - 1)
            return;

        // index j out of boundary
        if (j < 0 || j > m[0].length - 1)
            return;

        //add the current value to the sum
        sum += m[i][j];

        // reached the end of m
        if (i == m.length - 1 && j == m.length - 1) {
            System.out.println(sum);
            return;
        }

        final int BEEN_HERE = -10;

        // avoid repeat a cell
        int temp = m[i][j];
        m[i][j] = BEEN_HERE;

        // go right
        if (j + 1 < m[0].length && m[i][j + 1] >= 0)
            printPathWeights(m, i, j + 1, sum);
        // go left
        if (j - 1 > 0 && m[i][j - 1] >= 0)
            printPathWeights(m, i, j - 1, sum);
        // go up
        if (i - 1 > 0 && m[i - 1][j] >= 0)
            printPathWeights(m, i - 1, j, sum);
        // go down
        if (i + 1 < m.length && m[i + 1][j] >= 0)
            printPathWeights(m, i + 1, j, sum);

        m[i][j] = temp;
    }

    public static void printPathWeights2 (int[][] m) {
        printPathWeights2(m, 0, 0, 0);
    }

    ////
    /**
     * Recursive methods for various algorithmic problems.
     */


    // *** 2022a moed 67 ***

    /**
     * Checks if a submatrix in the given matrix is an identity matrix.
     *
     * @param mat  The input matrix.
     * @param x    Starting row index for the submatrix.
     * @param size Size of the submatrix.
     * @return True if the submatrix is an identity matrix, false otherwise.
     */
    public static boolean isIdentity (int[][] mat, int x, int size) {
        if (x + size - 1 > mat.length - 1)
            return false;
        return isIdentity(mat, x, size, x, x, x + size - 1);
    }

    private static boolean isIdentity (int[][] mat, int zero, int size, int i, int j, int n) {

        if (i > n || i < zero || j > n || j < zero)
            return false;
        if (i == j && mat[i][j] != 1)
            return false;
        if (i != j && mat[i][j] != 0)
            return false;
        if (mat[i][j] == 1 && i == n && j == n)
            return true;

        //turn right
        if (isIdentity(mat, zero, size, i, j + 1, n))
            return true;
        //turn down
        if (isIdentity(mat, zero, size, i + 1, zero, n))
            return true;

        //didnt reach anything
        return false;
    }

    /**
     * Finds the maximum size of a submatrix with an identity matrix structure in the given matrix.
     *
     * @param mat The input matrix.
     * @return The maximum size of the submatrix.
     */
    public static int maxMatrix (int[][] mat) {
        int center = mat.length / 2;
        if (mat.length % 2 != 1 || mat[center][center] != 1)
            return 0;
        return maxMatrix(mat, center, 1, center);
    }

    private static int maxMatrix (int[][] mat, int i, int sizeOfCenterMat, int center) {
        if (i - 1 < 0 || i + center > mat.length - 1)
            return 0;

        if (isIdentity(mat, i - 1, sizeOfCenterMat + 1)) {
            return sizeOfCenterMat + maxMatrix(mat, i - 1, sizeOfCenterMat + 1, center);
        }
        return 0;

    }

    // *** 2021b ***

    /**
     * Prints all possible expressions using the elements of the array that evaluate to the given num.
     *
     * @param arr The input array of integers.
     * @param num The target sum.
     * @return The number of valid expressions.
     */
    public static int printExpr (int[] arr, int num) {
        if (arr.length == 0)
            return 0;
        return printExpr(arr, num, 0, 0, 0, "");
    }

    private static int printExpr (int[] arr, int num, int i, int j, int sum, String s) {

        if (j > arr.length - 1)
            return 0;

//        if (i == arr.length - 1) {
//          return printExpr(arr, num, j+1, j+1, 0, "");
//        }

        if (i >= arr.length)
            return 0;

        if (num == sum) {
            //   System.out.println("\n***\nnum = " + num + " sum = " + sum + "\ni = " + i + " J = " + j + "\n***");
            System.out.println(s);
            return 1 + printExpr(arr, num, j + 1, j + 1, 0, "");
        }

        int k = 0, h = 0, p = 0;

        // add the arr[i] to sum
        if (printExpr(arr, num, i + 1, j, sum + arr[i], s) > 0)
            k = printExpr(arr, num, i + 1, j, sum + arr[i], s + " +" + arr[i]);

        // sub the arr[i] from sum
        if (printExpr(arr, num, i + 1, j, sum - arr[i], s) > 0)
            h = printExpr(arr, num, i + 1, j, sum - arr[i], s + " -" + arr[i]);

        // go forward in the array without taking action
        p = printExpr(arr, num, i + 1, j, sum, s);

        return k + h + p;
    }

    // *** 2018 ***

    /**
     * Finds the cost of the cheapest route between the first and last stations.
     *
     * @param stations The input array representing the cost of each station.
     * @return The cost of the cheapest route.
     */
    public static int cheapestRoute (int[] stations) {
        if (stations.length < 1)
            return 0;
        return cheapestRoute(stations, 0, 0);
    }

    private static int cheapestRoute (int[] stations, int i, int sum) {

        if (i >= stations.length)
            return 0;

        sum += stations[i];

        if (i == stations.length - 2)
            return sum + stations[i + 1];

        //reach the last station
        if (i == stations.length - 1)
            return sum;

        return Math.min(cheapestRoute(stations, i + 1, sum),
                cheapestRoute(stations, i + 2, sum));
    }

    /**
     * Sorts the array 'arr' using a modified quicksort with a specified modulus 'k'.
     *
     * @param arr The input array of integers.
     * @param k   The modulus for sorting.
     */
    public static void sortMod (int[] arr, int k) {
        if (arr.length <= 1)
            return;
        sortMod(arr, k, 0, arr.length - 1);
    }

    private static void sortMod (int[] arr, int k, int low, int high) {
        if (low < high) {
            int m = partition(arr, low, high, k);
            sortMod(arr, k, low, m - 1);
            sortMod(arr, k, m + 1, high);
        }
    }

    private static int partition (int[] arr, int low, int high, int k) {
        int left = low, right = high, pivot = arr[low];
        while (left < right) {
            while (left < right && (arr[left] % k <= pivot % k))
                left++;
            while (left < right && (arr[right] % k > pivot % k))
                right--;
            if (left < right)
                swap(arr, left, right);
        }
        swap(arr, low, right);
        return right;
    }

    private static void swap (int[] array, int left, int right) {
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }

    /**
     * Counts the number of ways to reach a sum 'k' using increments and decrements of 1 starting from 'n'.
     *
     * @param n The starting value.
     * @param k The target sum.
     * @return The number of ways to reach the sum.
     */
    public static int ways (int n, int k) {
        if (n == 0 && k == 0)
            return 1;
        if (k < 0)
            return 0;
        return ways(n + 1, k - 1) + ways(n - 1, k - 1);
    }

    /**
     * Checks if there are two elements in the sorted array that sum up to the given 'sum'.
     *
     * @param a   The sorted array of integers.
     * @param sum The target sum.
     * @return True if there are two elements that sum up to 'sum', false otherwise.
     */
    public static boolean findSum (int[] a, int sum) {

        if (a.length < 2)
            return false;

        returnToSortArray(a);
        int left = 0, right = a.length - 1, middle = 0;

        if (a[left] + a[right] == sum || a[left + 1] + a[right] == sum || a[left] + a[right - 1] == sum)
            return true;
        while (left <= right) {

            middle = (left + right) / 2;

            if (a[left] + a[middle] == sum || a[right] + a[middle] == sum)
                return true;

            if (a[left] + a[middle] > sum) {
                right = middle - 1;
            }

            if (a[right] + a[middle] < sum) {
                left = middle + 1;
            }

        }

        return false;
    }


    // *** 2017 ***

    public static void returnToSortArray (int[] a) {
        if (a.length < 2)
            return;
        // the array is already sorted
        if (a[0] < a[a.length - 1])
            return;

        int left = 0, right = a.length - 1, middle = 0, biggestNum = 0;

        // find the biggest num of the array
        while (left <= right) {
            middle = (left + right) / 2;
            if (a[middle] > a[middle - 1] && a[middle] > a[middle + 1]) {
                biggestNum = a[middle];
                break;
            }
            // the biggest is on the left side
            if (a[left] > a[right] && a[middle] < a[left]) {
                right = middle - 1;
            }
            // the biggest is on the right side
            if (a[left] < a[middle] && a[middle] > a[middle - 1]) {
                left = middle + 1;
            }
        }
        int temp, j = middle + 1;
        //sort the array back to original
        for (int i = 0; i < a.length; i++) {

            if (biggestNum == a[a.length - 1])
                return;
            if (i + j >= a.length - 1) {
                j = ((a.length - 1) - i);
            }
            temp = a[i];
            a[i] = a[i + j];
            a[j + i] = temp;
        }
    }


    /**
     * Checks if there is a Pythagorean triplet in the given array.
     *
     * @param arr The input array of integers.
     * @return True if a Pythagorean triplet is found, false otherwise.
     */
    public static boolean isPythagorean (int[] arr) {
        int n = arr.length;
        if (n < 2)
            return false;

        int a, b, c;

        for (c = n - 2; c > 1; c--) {
            a = 0;
            b = c - 1;
            while (a < b) {
                if ((Math.pow(arr[a], 2) + Math.pow(arr[b], 2)) == Math.pow(arr[c], 2))
                    return true;
                if ((Math.pow(arr[a], 2) + Math.pow(arr[b], 2)) > Math.pow(arr[c], 2)) {
                    b--;
                } else {
                    a++;
                }
            }
        }
        return false;
    }

    // *** 2017 85 a4 ***

    /**
     * Counts the minimum number of 1, 5, and 7 needed to represent the given 'n'.
     *
     * @param n The target number.
     * @return The minimum count of 1, 5, and 7.
     */
    public static int oneFiveSeven (int n) {
        if (n < 0)
            return -1;
        if (n == 0)
            return 0;
        return oneFiveSeven(n, 0, n, n, n);
    }

    private static int oneFiveSeven (int n, int theSum, int sum1, int sum2, int sum3) {
        if (n == 0)
            return theSum;
        if ((n - 5) >= 0)
            sum2 = oneFiveSeven(n - 5, theSum + 1, sum1, sum2, sum3);

        if ((n - 7) >= 0)
            sum3 = oneFiveSeven(n - 7, theSum + 1, sum1, sum2, sum3);

        if (n - 1 >= 0)
            sum1 = oneFiveSeven(n - 1, theSum + 1, sum1, sum2, sum3);

        return Math.min(sum1, Math.min(sum2, sum3));
    }


    // *** 2022a moed 67 ***

    /**
     * Checks if a submatrix in the given matrix is an identity matrix.
     *
     * @param mat  The input matrix.
     * @param x    Starting row index for the submatrix.
     * @param size Size of the submatrix.
     * @return True if the submatrix is an identity matrix, false otherwise.
     */
    public static boolean isIdentity (int[][] mat, int x, int size) {
        if (x + size - 1 > mat.length - 1)
            return false;
        return isIdentity(mat, x, size, x, x, x + size - 1);
    }

    private static boolean isIdentity (int[][] mat, int zero, int size, int i, int j, int n) {

        if (i > n || i < zero || j > n || j < zero)
            return false;
        if (i == j && mat[i][j] != 1)
            return false;
        if (i != j && mat[i][j] != 0)
            return false;
        if (mat[i][j] == 1 && i == n && j == n)
            return true;

        //turn right
        if (isIdentity(mat, zero, size, i, j + 1, n))
            return true;
        //turn down
        if (isIdentity(mat, zero, size, i + 1, zero, n))
            return true;

        //didnt reach anything
        return false;
    }


    /**
     * Finds the maximum size of a submatrix with an identity matrix structure in the given matrix.
     *
     * @param mat The input matrix.
     * @return The maximum size of the submatrix.
     */
    public static int maxMatrix (int[][] mat) {
        int center = mat.length / 2;
        if (mat.length % 2 != 1 || mat[center][center] != 1)
            return 0;
        return maxMatrix(mat, center, 1, center);
    }

    private static int maxMatrix (int[][] mat, int i, int sizeOfCenterMat, int center) {
        if (i - 1 < 0 || i + center > mat.length - 1)
            return 0;

        if (isIdentity(mat, i - 1, sizeOfCenterMat + 1)) {
            return sizeOfCenterMat + maxMatrix(mat, i - 1, sizeOfCenterMat + 1, center);
        }
        return 0;

    }


}




